"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/inventory/page",{

/***/ "(app-pages-browser)/./src/hooks/useLocalStorage.ts":
/*!**************************************!*\
  !*** ./src/hooks/useLocalStorage.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n/**\n * Custom hook for using localStorage with React state\n * @param key The localStorage key\n * @param initialValue The initial value if nothing is in localStorage\n * @returns [storedValue, setValue, { error, isLoading }]\n */ function useLocalStorage(key, initialValue) {\n    // State to store our value\n    const [storedValue, setStoredValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        if (false) {}\n        try {\n            // Get from local storage by key\n            const item = window.localStorage.getItem(key);\n            // Parse stored json or if none return initialValue\n            return item ? JSON.parse(item) : initialValue;\n        } catch (error) {\n            // If error also return initialValue\n            console.log(error);\n            return initialValue;\n        }\n    });\n    // State for error handling and loading state\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Function to safely parse JSON with error handling\n    const safelyParseJSON = (json)=>{\n        if (!json) return null;\n        try {\n            return JSON.parse(json);\n        } catch (e) {\n            console.error(\"Error parsing JSON from localStorage:\", e);\n            setError(e instanceof Error ? e : new Error(String(e)));\n            return null;\n        }\n    };\n    // Initialize from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        try {\n            setIsLoading(true);\n            // Check if we're in a browser environment\n            if (false) {}\n            // Get from localStorage\n            const item = window.localStorage.getItem(key);\n            const parsedItem = safelyParseJSON(item);\n            // If item exists, use it, otherwise use initialValue\n            setStoredValue(parsedItem !== null ? parsedItem : initialValue);\n            // Create a storage event listener to sync state across tabs\n            const handleStorageChange = (e)=>{\n                if (e.key === key && e.newValue !== null) {\n                    const newValue = safelyParseJSON(e.newValue);\n                    if (newValue !== null) {\n                        setStoredValue(newValue);\n                    }\n                }\n            };\n            // Listen for changes in other tabs/windows\n            window.addEventListener(\"storage\", handleStorageChange);\n            setIsLoading(false);\n            // Clean up\n            return ()=>{\n                window.removeEventListener(\"storage\", handleStorageChange);\n            };\n        } catch (e) {\n            console.error(\"Error in useLocalStorage initialization:\", e);\n            setError(e instanceof Error ? e : new Error(String(e)));\n            setIsLoading(false);\n        }\n    }, [\n        key,\n        initialValue\n    ]);\n    // Return a wrapped version of useState's setter function that\n    // persists the new value to localStorage\n    const setValue = (value)=>{\n        try {\n            // Allow value to be a function so we have the same API as useState\n            const valueToStore = value instanceof Function ? value(storedValue) : value;\n            // Save state\n            setStoredValue(valueToStore);\n            // Check if we're in a browser environment\n            if (true) {\n                // Save to localStorage\n                const serializedValue = JSON.stringify(valueToStore);\n                window.localStorage.setItem(key, serializedValue);\n                // Dispatch a custom event so other tabs can listen for changes\n                window.dispatchEvent(new StorageEvent(\"storage\", {\n                    key,\n                    newValue: serializedValue\n                }));\n            }\n        } catch (e) {\n            console.error(\"Error setting localStorage value:\", e);\n            setError(e instanceof Error ? e : new Error(String(e)));\n        }\n    };\n    // Update stored value if the key changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            try {\n                const item = window.localStorage.getItem(key);\n                if (item) {\n                    setStoredValue(JSON.parse(item));\n                }\n            } catch (error) {\n                console.log(error);\n            }\n        }\n    }, [\n        key\n    ]);\n    return [\n        storedValue,\n        setValue,\n        {\n            error,\n            isLoading\n        }\n    ];\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (useLocalStorage);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VMb2NhbFN0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7OzZEQUU0QztBQVM1Qzs7Ozs7Q0FLQyxHQUNELFNBQVNFLGdCQUFtQkMsR0FBVyxFQUFFQyxZQUFlO0lBQ3RELDJCQUEyQjtJQUMzQixNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBR04sK0NBQVFBLENBQUk7UUFDaEQsSUFBSSxLQUFrQixFQUFhLEVBRWxDO1FBQ0QsSUFBSTtZQUNGLGdDQUFnQztZQUNoQyxNQUFNTyxPQUFPQyxPQUFPQyxZQUFZLENBQUNDLE9BQU8sQ0FBQ1A7WUFDekMsbURBQW1EO1lBQ25ELE9BQU9JLE9BQU9JLEtBQUtDLEtBQUssQ0FBQ0wsUUFBUUg7UUFDbkMsRUFBRSxPQUFPUyxPQUFPO1lBQ2Qsb0NBQW9DO1lBQ3BDQyxRQUFRQyxHQUFHLENBQUNGO1lBQ1osT0FBT1Q7UUFDVDtJQUNGO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU0sQ0FBQ1MsT0FBT0csU0FBUyxHQUFHaEIsK0NBQVFBLENBQWU7SUFDakQsTUFBTSxDQUFDaUIsV0FBV0MsYUFBYSxHQUFHbEIsK0NBQVFBLENBQUM7SUFFM0Msb0RBQW9EO0lBQ3BELE1BQU1tQixrQkFBa0IsQ0FBQ0M7UUFDdkIsSUFBSSxDQUFDQSxNQUFNLE9BQU87UUFFbEIsSUFBSTtZQUNGLE9BQU9ULEtBQUtDLEtBQUssQ0FBQ1E7UUFDcEIsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZQLFFBQVFELEtBQUssQ0FBQyx5Q0FBeUNRO1lBQ3ZETCxTQUFTSyxhQUFhQyxRQUFRRCxJQUFJLElBQUlDLE1BQU1DLE9BQU9GO1lBQ25ELE9BQU87UUFDVDtJQUNGO0lBRUEsd0NBQXdDO0lBQ3hDcEIsZ0RBQVNBLENBQUM7UUFDUixJQUFJO1lBQ0ZpQixhQUFhO1lBRWIsMENBQTBDO1lBQzFDLElBQUksS0FBa0IsRUFBYSxFQUlsQztZQUVELHdCQUF3QjtZQUN4QixNQUFNWCxPQUFPQyxPQUFPQyxZQUFZLENBQUNDLE9BQU8sQ0FBQ1A7WUFDekMsTUFBTXNCLGFBQWFOLGdCQUFnQlo7WUFFbkMscURBQXFEO1lBQ3JERCxlQUFlbUIsZUFBZSxPQUFPQSxhQUFhckI7WUFFbEQsNERBQTREO1lBQzVELE1BQU1zQixzQkFBc0IsQ0FBQ0w7Z0JBQzNCLElBQUlBLEVBQUVsQixHQUFHLEtBQUtBLE9BQU9rQixFQUFFTSxRQUFRLEtBQUssTUFBTTtvQkFDeEMsTUFBTUEsV0FBV1IsZ0JBQWdCRSxFQUFFTSxRQUFRO29CQUMzQyxJQUFJQSxhQUFhLE1BQU07d0JBQ3JCckIsZUFBZXFCO29CQUNqQjtnQkFDRjtZQUNGO1lBRUEsMkNBQTJDO1lBQzNDbkIsT0FBT29CLGdCQUFnQixDQUFDLFdBQVdGO1lBRW5DUixhQUFhO1lBRWIsV0FBVztZQUNYLE9BQU87Z0JBQ0xWLE9BQU9xQixtQkFBbUIsQ0FBQyxXQUFXSDtZQUN4QztRQUNGLEVBQUUsT0FBT0wsR0FBRztZQUNWUCxRQUFRRCxLQUFLLENBQUMsNENBQTRDUTtZQUMxREwsU0FBU0ssYUFBYUMsUUFBUUQsSUFBSSxJQUFJQyxNQUFNQyxPQUFPRjtZQUNuREgsYUFBYTtRQUNmO0lBQ0YsR0FBRztRQUFDZjtRQUFLQztLQUFhO0lBRXRCLDhEQUE4RDtJQUM5RCx5Q0FBeUM7SUFDekMsTUFBTTBCLFdBQW9ELENBQUNDO1FBQ3pELElBQUk7WUFDRixtRUFBbUU7WUFDbkUsTUFBTUMsZUFDSkQsaUJBQWlCRSxXQUFXRixNQUFNMUIsZUFBZTBCO1lBRW5ELGFBQWE7WUFDYnpCLGVBQWUwQjtZQUVmLDBDQUEwQztZQUMxQyxJQUFJLElBQWtCLEVBQWE7Z0JBQ2pDLHVCQUF1QjtnQkFDdkIsTUFBTUUsa0JBQWtCdkIsS0FBS3dCLFNBQVMsQ0FBQ0g7Z0JBQ3ZDeEIsT0FBT0MsWUFBWSxDQUFDMkIsT0FBTyxDQUFDakMsS0FBSytCO2dCQUVqQywrREFBK0Q7Z0JBQy9EMUIsT0FBTzZCLGFBQWEsQ0FBQyxJQUFJQyxhQUFhLFdBQVc7b0JBQy9DbkM7b0JBQ0F3QixVQUFVTztnQkFDWjtZQUNGO1FBQ0YsRUFBRSxPQUFPYixHQUFHO1lBQ1ZQLFFBQVFELEtBQUssQ0FBQyxxQ0FBcUNRO1lBQ25ETCxTQUFTSyxhQUFhQyxRQUFRRCxJQUFJLElBQUlDLE1BQU1DLE9BQU9GO1FBQ3JEO0lBQ0Y7SUFFQSx5Q0FBeUM7SUFDekNwQixnREFBU0EsQ0FBQztRQUNSLElBQUksSUFBa0IsRUFBYTtZQUNqQyxJQUFJO2dCQUNGLE1BQU1NLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ0MsT0FBTyxDQUFDUDtnQkFDekMsSUFBSUksTUFBTTtvQkFDUkQsZUFBZUssS0FBS0MsS0FBSyxDQUFDTDtnQkFDNUI7WUFDRixFQUFFLE9BQU9NLE9BQU87Z0JBQ2RDLFFBQVFDLEdBQUcsQ0FBQ0Y7WUFDZDtRQUNGO0lBQ0YsR0FBRztRQUFDVjtLQUFJO0lBRVIsT0FBTztRQUFDRTtRQUFheUI7UUFBVTtZQUFFakI7WUFBT0k7UUFBVTtLQUFFO0FBQ3REO0FBRUEsK0RBQWVmLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUxvY2FsU3RvcmFnZS50cz83NmY0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZSBmb3IgdGhlIGhvb2sncyByZXR1cm4gdmFsdWVcbnR5cGUgVXNlTG9jYWxTdG9yYWdlUmV0dXJuPFQ+ID0gW1xuICBULFxuICBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxUPj4sXG4gIHsgZXJyb3I6IEVycm9yIHwgbnVsbDsgaXNMb2FkaW5nOiBib29sZWFuIH1cbl07XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgZm9yIHVzaW5nIGxvY2FsU3RvcmFnZSB3aXRoIFJlYWN0IHN0YXRlXG4gKiBAcGFyYW0ga2V5IFRoZSBsb2NhbFN0b3JhZ2Uga2V5XG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIGlmIG5vdGhpbmcgaXMgaW4gbG9jYWxTdG9yYWdlXG4gKiBAcmV0dXJucyBbc3RvcmVkVmFsdWUsIHNldFZhbHVlLCB7IGVycm9yLCBpc0xvYWRpbmcgfV1cbiAqL1xuZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlPFQ+KGtleTogc3RyaW5nLCBpbml0aWFsVmFsdWU6IFQpOiBVc2VMb2NhbFN0b3JhZ2VSZXR1cm48VD4ge1xuICAvLyBTdGF0ZSB0byBzdG9yZSBvdXIgdmFsdWVcbiAgY29uc3QgW3N0b3JlZFZhbHVlLCBzZXRTdG9yZWRWYWx1ZV0gPSB1c2VTdGF0ZTxUPigoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZyb20gbG9jYWwgc3RvcmFnZSBieSBrZXlcbiAgICAgIGNvbnN0IGl0ZW0gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIC8vIFBhcnNlIHN0b3JlZCBqc29uIG9yIGlmIG5vbmUgcmV0dXJuIGluaXRpYWxWYWx1ZVxuICAgICAgcmV0dXJuIGl0ZW0gPyBKU09OLnBhcnNlKGl0ZW0pIDogaW5pdGlhbFZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiBlcnJvciBhbHNvIHJldHVybiBpbml0aWFsVmFsdWVcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIFN0YXRlIGZvciBlcnJvciBoYW5kbGluZyBhbmQgbG9hZGluZyBzdGF0ZVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcblxuICAvLyBGdW5jdGlvbiB0byBzYWZlbHkgcGFyc2UgSlNPTiB3aXRoIGVycm9yIGhhbmRsaW5nXG4gIGNvbnN0IHNhZmVseVBhcnNlSlNPTiA9IChqc29uOiBzdHJpbmcgfCBudWxsKTogVCB8IG51bGwgPT4ge1xuICAgIGlmICghanNvbikgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pIGFzIFQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBKU09OIGZyb20gbG9jYWxTdG9yYWdlOicsIGUpO1xuICAgICAgc2V0RXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBFcnJvcihTdHJpbmcoZSkpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyBJbml0aWFsaXplIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCd1c2VMb2NhbFN0b3JhZ2UgY2FsbGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IGl0ZW0gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGNvbnN0IHBhcnNlZEl0ZW0gPSBzYWZlbHlQYXJzZUpTT04oaXRlbSk7XG4gICAgICBcbiAgICAgIC8vIElmIGl0ZW0gZXhpc3RzLCB1c2UgaXQsIG90aGVyd2lzZSB1c2UgaW5pdGlhbFZhbHVlXG4gICAgICBzZXRTdG9yZWRWYWx1ZShwYXJzZWRJdGVtICE9PSBudWxsID8gcGFyc2VkSXRlbSA6IGluaXRpYWxWYWx1ZSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0b3JhZ2UgZXZlbnQgbGlzdGVuZXIgdG8gc3luYyBzdGF0ZSBhY3Jvc3MgdGFic1xuICAgICAgY29uc3QgaGFuZGxlU3RvcmFnZUNoYW5nZSA9IChlOiBTdG9yYWdlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBrZXkgJiYgZS5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc2FmZWx5UGFyc2VKU09OKGUubmV3VmFsdWUpO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3RvcmVkVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIGluIG90aGVyIHRhYnMvd2luZG93c1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBoYW5kbGVTdG9yYWdlQ2hhbmdlKTtcbiAgICAgIFxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgaGFuZGxlU3RvcmFnZUNoYW5nZSk7XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHVzZUxvY2FsU3RvcmFnZSBpbml0aWFsaXphdGlvbjonLCBlKTtcbiAgICAgIHNldEVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoU3RyaW5nKGUpKSk7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2tleSwgaW5pdGlhbFZhbHVlXSk7XG5cbiAgLy8gUmV0dXJuIGEgd3JhcHBlZCB2ZXJzaW9uIG9mIHVzZVN0YXRlJ3Mgc2V0dGVyIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcGVyc2lzdHMgdGhlIG5ldyB2YWx1ZSB0byBsb2NhbFN0b3JhZ2VcbiAgY29uc3Qgc2V0VmFsdWU6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFQ+PiA9ICh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBbGxvdyB2YWx1ZSB0byBiZSBhIGZ1bmN0aW9uIHNvIHdlIGhhdmUgdGhlIHNhbWUgQVBJIGFzIHVzZVN0YXRlXG4gICAgICBjb25zdCB2YWx1ZVRvU3RvcmUgPVxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdmFsdWUoc3RvcmVkVmFsdWUpIDogdmFsdWU7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgc3RhdGVcbiAgICAgIHNldFN0b3JlZFZhbHVlKHZhbHVlVG9TdG9yZSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlVG9TdG9yZSk7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWRWYWx1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBEaXNwYXRjaCBhIGN1c3RvbSBldmVudCBzbyBvdGhlciB0YWJzIGNhbiBsaXN0ZW4gZm9yIGNoYW5nZXNcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IFN0b3JhZ2VFdmVudCgnc3RvcmFnZScsIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV3VmFsdWU6IHNlcmlhbGl6ZWRWYWx1ZSxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgbG9jYWxTdG9yYWdlIHZhbHVlOicsIGUpO1xuICAgICAgc2V0RXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBFcnJvcihTdHJpbmcoZSkpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBkYXRlIHN0b3JlZCB2YWx1ZSBpZiB0aGUga2V5IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBzZXRTdG9yZWRWYWx1ZShKU09OLnBhcnNlKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2tleV0pO1xuXG4gIHJldHVybiBbc3RvcmVkVmFsdWUsIHNldFZhbHVlLCB7IGVycm9yLCBpc0xvYWRpbmcgfV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUxvY2FsU3RvcmFnZTsgIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlTG9jYWxTdG9yYWdlIiwia2V5IiwiaW5pdGlhbFZhbHVlIiwic3RvcmVkVmFsdWUiLCJzZXRTdG9yZWRWYWx1ZSIsIml0ZW0iLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwic2V0RXJyb3IiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzYWZlbHlQYXJzZUpTT04iLCJqc29uIiwiZSIsIkVycm9yIiwiU3RyaW5nIiwid2FybiIsInBhcnNlZEl0ZW0iLCJoYW5kbGVTdG9yYWdlQ2hhbmdlIiwibmV3VmFsdWUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFZhbHVlIiwidmFsdWUiLCJ2YWx1ZVRvU3RvcmUiLCJGdW5jdGlvbiIsInNlcmlhbGl6ZWRWYWx1ZSIsInN0cmluZ2lmeSIsInNldEl0ZW0iLCJkaXNwYXRjaEV2ZW50IiwiU3RvcmFnZUV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useLocalStorage.ts\n"));

/***/ })

});